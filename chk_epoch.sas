

%macro chk_epoch(path=, out=);

libname sdtm "&path";

filename out1 "&out/chk_epoch.rtf";
%custom;
ods rtf file=out1 style=custom;
options orientation=landscape;

data banner; 
line= "No discrepancy found for EPOCH";
run;


%list_files(path=&path);

data f1; set f1;
name=scan(names,1, '.');
if upcase(substr(name,1,4))='SUPP' then delete;
run;

data _null_; 
set f1 end=eof;
i+1;
call symput(compress("dataset"||put(i,best.)), trim(left(name)));
if eof then call symput("tota", trim(left(put(_n_,best.))));
run;

%do s=1 %to &tota;
proc contents data=sdtm.&&dataset&s noprint out=out&s;
data combine(keep=memname name); set %if &s=1 %then out1; %else combine out&s;; 
if name eq 'EPOCH' and memname notin ('SE','DM');
%end;

%do s=1 %to &tota;
proc contents data=sdtm.&&dataset&s noprint out=out&s;
data combine2(keep=memname name); set %if &s=1 %then out1; %else combine2 out&s;; 
if substr(compress(reverse(name)),1,3)='CTD' and memname notin ('SE','DM');
%end;

%do s=1 %to &tota;
proc contents data=sdtm.&&dataset&s noprint out=out&s;
data combine4(keep=memname name); set %if &s=1 %then out1; %else combine4 out&s;; 
if substr(compress(reverse(name)),1,3)='TPT' and memname notin ('SE','DM') and length(name)=5;
%end;

%do s=1 %to &tota;
proc contents data=sdtm.&&dataset&s noprint out=out&s;
data combine5(keep=memname name); set %if &s=1 %then out1; %else combine5 out&s;; 
if length(name)>=6;
if substr(compress(reverse(name)),1,6)='TPTRTS' and memname notin ('SE','DM');
%end;

%do s=1 %to &tota;
proc contents data=sdtm.&&dataset&s noprint out=out&s;
data combine6(keep=memname name); set %if &s=1 %then out1; %else combine6 out&s;; 
if length(name)>=3;
if substr(compress(reverse(name)),1,3)='QES' and memname notin ('SE','DM');
%end;


proc sort data=combine; by memname name;
proc sort data=combine2; by memname;
proc sort data=combine4(rename=name=tpt); by memname;
proc sort data=combine5(rename=name=strtpt); by memname;
proc sort data=combine6(rename=name=seq); by memname;


proc transpose data=combine2 out=combine3(drop=_name_ _label_) prefix=date;
by memname; 
var name;
run; 

data combine;
merge combine(in=a) combine3(in=b) combine4 combine5 combine6;
by memname;
if a;
len1=length(date1);
len2=length(date2);
if len1>=5;
if len1=5 then dtc=date1;
else if len2=5 then dtc=date2;
else if len1=7 and substr(reverse(compress(date1)),1,5)='CTDTS' then dtc=date1;
else if len2=7 and substr(reverse(compress(date2)),1,5)='CTDTS' then dtc=date2;
if dtc>' '; 
run;


title "Review of the variables used to derive EPOCH";
footnote1 justify=l "~R'\brdrt\brdrs\brdrw5'";
footnote2 "Generated by chk_epoch.sas, &sysdate &systime SAS &sysver in &sysscpl";

%let column1=Domain;
%let column2=Datetime Variable;
%let column3=Time Point;
%let column4=XXSTRTPT;
%let column5=XXSEQ;

%report_rtf3(indata=combine, columns=%str(memname dtc tpt strtpt seq)); 
run;

data _null_; 
set combine end=eof;
i+1;
call symput(compress('dataset'||put(i,best.)), trim(left(memname)));
call symput(compress('variable'||put(i,best.)), trim(left(dtc)));
call symput(compress('tpt'||put(i,best.)), trim(left(tpt)));
call symput(compress('strtpt'||put(i,best.)), trim(Left(strtpt)));
call symput(compress('seq'||put(i,best.)), trim(Left(seq)));

if eof then call symput('toti', trim(left(put(_n_,best.))));
run;


%do i=1 %to &toti;
proc sort data=sdtm.&&dataset&i out=&&dataset&i; by usubjid &&variable&i;
proc sort data=sdtm.se out=se2(keep=usubjid seseq sestdtc seendtc epoch rename=epoch=epoch_qc); by usubjid; 

proc sql;
create table se as 
select *, max(seseq) as maxseq 
from se2 
group by usubjid; 

proc sort data=se; by usubjid seseq;
data se(rename=usubjid=usubjid2); set se;
by usubjid seseq;
lagep=lag(epoch_qc);
if first.usubjid then lagep=' ';
run;

proc sql;
create table temp as 
select * from &&dataset&i full join se 
on &&dataset&i...usubjid=se.usubjid2; 

data &&dataset&i; set temp;
k=length(&&variable&i);
if (seseq ne maxseq and substr(sestdtc,1,k)<=&&variable&i<substr(seendtc,1,k)) or (seseq=maxseq and substr(sestdtc,1,k)<=&&variable&i<=substr(seendtc,1,k)); 
run;

** check if XXTPT or XXSTRTPT can help assigning epoch ;
** this part is study specific;  


%let tiaojian1=%str((length(&&variable&i)=length(sestdtc) and &&variable&i=sestdtc));
%let tiaojian2=%str((length(&&variable&i) ne length(sestdtc) and scan(&&variable&i,1,'T')=scan(sestdtc,1,'T'))); 

%if &&tpt&i ne %then %do;
data &&dataset&i; set &&dataset&i;
if index(upcase(&&tpt&i),'PRE-DOSE')>0 and (&tiaojian1 or &tiaojian2) and lagep>' ' then epoch_qc=lagep;
run;
%end;

%if &&strtpt&i ne %then %do;
data &&dataset&i; set &&dataset&i;
if index(upcase(&&strtpt&i),'PRE-DOSE')>0 and (&tiaojian1 or &tiaojian2) and lagep>' ' then epoch_qc=lagep;
run;
%end;





proc sort data=&&dataset&i; by usubjid &&seq&i seseq; 
data &&dataset&i; set &&dataset&i;
by usubjid &&seq&i seseq;
if %if &&seq&i ne %then %do; last.&&seq&i %end; %else %do; last.usubjid %end;;
run;

%if &&dataset&i=DS %then %do;
data ds; set ds;
if upcase(dscat)='PROTOCOL MILESTONE' then epoch_qc=' ';
run;
%end;

proc sql noprint ;
select count(*) into :ob from &&dataset&i
where epoch ne epoch_qc;

%if &ob=0 %then %do;


title "QC of the EPOCH in &&dataset&i";
footnote1 justify=l "~R'\brdrt\brdrs\brdrw5'";
footnote2 "Generated by chk_epoch.sas, &sysdate &systime SAS &sysver in &sysscpl";

%let column1=Banner;
%report_rtf3(indata=banner, columns=%str(line)); 

run;
%end;

%else %do;

title "QC of the Epoch in &&dataset&i";
footnote1 justify=l "~R'\brdrt\brdrs\brdrw5'";
footnote2 "Generated by chk_epoch.sas, &sysdate &systime SAS &sysver in &sysscpl";

%do k=1 %to 8;
%let column&k=; 
%end;
%let column3=epoch_qc;

%report_rtf3(indata=&&dataset&i, where=epoch ne epoch_qc, columns=%str(usubjid epoch epoch_qc &&variable&i sestdtc seendtc &&tpt&i &&strtpt&i)); 

run;
%end;
%end;


ods rtf close;
filename out1 clear;
proc datasets kill lib=work memtype=data nodetails nolist;
run;

%mend;







